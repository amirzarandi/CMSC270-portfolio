2. One approach to designing a version of MergeSort that does not require returning an array would be to pass the array as a reference parameter to the MergeSort function as my group did during the Search & Sort Competition. We defined the merge function that takes two sorted subarrays as reference parameters and merges them into a single sorted array. We also define the mergeSort function that takes the array as a reference parameter, splits the array into two halves, and recursively calls the mergeSort function on each half, and then calls the merge function to merge the two sorted halves.

3. In worst case scenario, it is more efficient to sort the list and then use binary search to find an element in the list, as binary search has a time complexity of $ O(\log n) $, while linear search has a time complexity of $ O(n) $. When we cobine binary search with a sorting algorithm like merge sort which has a time complexity of $ O(n \log n) $, our total time comlexity would be $ O(n \log n) $ which is more efficient than linear search for large numbers. For small lists, it may be more preferable to use linear search. If the list we're dealing with is not the worst case scenario (anti-sorted), linear search might perform better. And finally, for multiple searches, it's always better to sort the list and search it. So, for the genral case, it depends on the situation. 

4. Lots of similiarities, for instance, we still check for low <= high and change low and high based on the reraltion between mid and the element x. 